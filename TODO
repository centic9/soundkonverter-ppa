### Prio 1 ###


getCodecFromFile liefert nur dann einen mimetype wenn der codec nicht bekannt ist,
 dies wird nicht berücksichtigt, wenn der benutzer versucht nicht unterstützte dateien hinzuzufügen (z.b. wma beim replay gain tool)


flac piping
filelist progress bar translucent background
bug: filelist progress bar sometimes scans multiple times - parent directory is scanned - not reproduceable

logs einfärben -> backend fehler hervorheben
cdtext
user scripts
edit ripper parameters
edit encoder parameters [/]
copy custom tags / lyrics
cover downloading
musicbrianz

cdopener.cpp / bluray -> ask users for `cat /proc/sys/dev/cdrom/info`

### Prio 2 ###

hybrid formats
optimize profiles
better ripping control
use qt animations
ReplayGainScanner: Drag'n'Drop ... verbesserungswürdig, funktioniert aber grundsätzlich
ReplayGainScanner: split album through context menu
ReplayGainScanner: split albums by disc
ReplayGainScanner: parallele Berechnung
changing default decoder only takes effect after restart

### Prio 3 ###



### Plugins ###
[x] faac
[x] ffmpeg
[x] flac
[x] lame
[x] mplayer
[x] neroaac
[x] timidity
[x] fluidsynth
[x] vorbistools
[x] twolame
[ ] gogo
[x] musepack
[ ] mpc123
[x] aften
[x] flake
[x] mac
[x] shorten
[x] tta
[ ] bonk
[ ] optimfrog
[x] wavpack
[ ] lac
[ ] lpac
[x] speex
[>] sox
[>] gstreamer
[ ] phonon?

[x] aacgain
[x] metaflac
[x] mp3gain
[x] vorbisgain
[x] wvgain
[x] replaygain

[x] cdparanoia
[>] cdda2wav


### Code ###

KShell::quoteArg

https://code.google.com/r/johntyree-gogglesmm/source/browse/src/GMTag.cpp?r=744628216e15f5804ff69b767d46405aa77e8ae8

### main.cpp ###

signal( SIGQUIT, cleanup );
signal( SIGINT, cleanup );

void cleanup( int )
{
    kDebug(5970) << i18n("Just caught a software interrupt.");
    kapp->exit();
}


Create a named pipe called pipe.wav
#: mkfifo pipe.wav

Now execute the following command. It will hang, as it is waiting for the data to flow through the pipe.
#: lame --preset standard pipe.wav output.file

In a different terminal, execute the following command, to get the data flowing.
#: mplayer -ao pcm:file=pipe.wav input.file


QFile debugfile("/dev/shm/soundKonverter");
if( debugfile.open(QIODevice::Append|QIODevice::Text) )
{
    QTextStream debugstream(&debugfile);
    debugstream << "type: " << data << "\n";
    debugfile.close();
}


QFile debugfile("/dev/shm/soundKonverter");
debugfile.open(QIODevice::Append|QIODevice::Text);
QTextStream debugstream(&debugfile);
debugstream << "type: " << data << "\n";
debugfile.close();

###


deviceList = Solid::Device::listFromType( Solid::DeviceInterface::OpticalDisc );
foreach( const Solid::Device &device, deviceList )
{
debug() << "Found Solid::DeviceInterface::OpticalDisc with udi = " << device.udi();
debug() << "Device name is = " << device.product() << " and was made by " << device.vendor();

const Solid::OpticalDisc * opt = device.as<Solid::OpticalDisc>();

if ( opt && opt->availableContent() & Solid::OpticalDisc::Audio )
{
debug() << "device is an Audio CD";
m_type[device.udi()] = MediaDeviceCache::SolidAudioCdType;
m_name[device.udi()] = device.vendor() + " - " + device.product();
}
}


### debug

FileList::load
                    switch(qrand()%4)
                    {
                        case 0:
                            item->state = FileListItem::WaitingForConversion;
                            break;
                        case 1:
                            item->state = FileListItem::Converting;
                            break;
                        case 2:
                            item->state = FileListItem::Failed;
                            break;
                        case 3:
                            item->state = FileListItem::WaitingForAlbumGain;
                            break;
                    }

